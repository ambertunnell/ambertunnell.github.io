<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: methods_magic | amber_tunnell = Rubyist.new]]></title>
  <link href="http://ambertunnell.github.io/blog/categories/methods-magic/atom.xml" rel="self"/>
  <link href="http://ambertunnell.github.io/"/>
  <updated>2014-07-18T22:16:29-04:00</updated>
  <id>http://ambertunnell.github.io/</id>
  <author>
    <name><![CDATA[Amber Tunnell]]></name>
    <email><![CDATA[amber.tunnell@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby magic]]></title>
    <link href="http://ambertunnell.github.io/blog/2014/06/15/hidden-ruby-magic-tricks/"/>
    <updated>2014-06-15T17:53:07-04:00</updated>
    <id>http://ambertunnell.github.io/blog/2014/06/15/hidden-ruby-magic-tricks</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning Ruby for about 2-3 months now, and I&rsquo;ve already fallen in love. Hard. The language is so intuitive that often I find myself trying methods in Ruby that I&rsquo;ve never learned about just because I think there is a good chance they&rsquo;ll work. And, often if they don&rsquo;t do exactly what I thought they did, they still do something interesting that is awesome. <!-- more --></p>

<p>In this post, I plan to discuss hidden Ruby tricks that many beginning Rubyists might not know about (yet!) that I&rsquo;ve discovered online or through playing around with Ruby. This is by no means a comprehensive list, but I hope it illustrates a few of Ruby&rsquo;s awesome tricks. They are all included in the <a href="http://ruby-doc.org/">Ruby Documentation</a> if you want to learn more. Also, shout out in the comments if you know of any other good ones to add to the list!</p>

<h2><code>.collect.with_index</code></h2>

<p>This one may seem obvious to most, but it was a happy discovery for me last week when I was trying to solve a problem. I had been familiar with the method <code>.each.with_index</code> for a while, and every time I needed to use indexes while iterating, I used it. However, I prefer <code>.collect</code> over <code>.each</code> in most cases, and was frustrated that I couldn&rsquo;t use indexes with collect. I&rsquo;m not sure why I thought it could only work with <code>.each</code>, but I did for a while. But then I tried it with <code>.collect</code>, and it worked! .<code>collect.with_index</code> is a real thing! So, the method <code>.with_index</code> can work on either <code>.each</code> or <code>.collect</code>.</p>

<p>In general, <code>.collect</code> is preferable to <code>.each</code> in any iteration where you are trying to collect data from a block into a new array. The code written with <code>.collect</code> will be cleaner and more concise, as shown in the example below.</p>

<p>``` ruby each.with_index
array = [1,2,3,4]</p>

<p>new_array = Array.new
array.each.with_index {|num, index| new_array &lt;&lt; num * index }
new_array #=> [0,2,6,12]
```</p>

<p>``` ruby collect.with_index
array = [1,2,3,4]</p>

<p>new_array = array.collect.with_index {|num, index| num * index}
new_array #=> [0,2,6,12]
```</p>

<h2><code>.freeze</code></h2>

<p>Freeze! Because this is Ruby, the method <code>.freeze</code> does exactly what you think it does. It freezes the object from being altered in any way. And you can even check if an object is frozen by asking it if it&rsquo;s frozen! This may be useful if you have a class that you want to alter in your program until a certain condition is met, then if you want the object to be immutable you can just <code>.freeze</code> it from that point on.</p>

<p><code>ruby .freeze
array = [1,2,3]
array.freeze
array.collect! {|num| num * 27}
  #=&gt; "RuntimeError: can't modify frozen Array"
array.frozen?
  #=&gt; true
</code></p>

<h2><code>.to_s(base)</code></h2>

<p>This was a cool discovery for me. If you convert an integer to a string (using <code>.to_s</code>), it can take an argument that will convert it to a different base. It works up to base 36.</p>

<p>``` ruby .to_s(base)</p>

<h1>2 in binary</h1>

<p>2.to_s(2) #=> &ldquo;10&rdquo;</p>

<h1>converting to binary</h1>

<p>5678437.to_s(2) #=> &ldquo;10101101010010101100101&rdquo;</p>

<h1>converting to base 23</h1>

<p>5678437.to_s(23) #=> &ldquo;k6g6d&rdquo;
```</p>

<h2>Splat <code>*</code> symbol</h2>

<p>Splat(<code>*</code>) is very cool and powerful. Here&rsquo;s a few splat tricks I&rsquo;ve learned.</p>

<h3>allows an array to take unspecified amount of arguments</h3>

<p>It allows an array to take any number of arguments, and returns those values in a array. You can use it with other aguments, if you want to separate the first or last argument from the array.</p>

<p>``` ruby splat_power</p>

<h1>splat argument as the only arugment</h1>

<p>def splat_is_awesome(*a)
  a
end</p>

<p>splat_is_awesome(&ldquo;and&rdquo;,&ldquo;it&rdquo;,&ldquo;looks&rdquo;,&ldquo;cool&rdquo;,&ldquo;too&rdquo;)<br/>
 #=> [&ldquo;and&rdquo;, &ldquo;it&rdquo;, &ldquo;looks&rdquo;, &ldquo;cool&rdquo;, &ldquo;too&rdquo;]</p>

<h1>splat as last argument</h1>

<p>def splat_power(a,*b)
  [a,b]
end</p>

<p>splat_power(&ldquo;powerful&rdquo;,&ldquo;stuff&rdquo;,&ldquo;here&rdquo;)
 #=> [&ldquo;powerful&rdquo;, [&ldquo;stuff&rdquo;, &ldquo;here&rdquo;]]</p>

<h1>splat as first argument</h1>

<p>def splat_power_reversed(*a,b)
  [a,b]
end</p>

<p>splat_power_reversed(&ldquo;powerful&rdquo;,&ldquo;stuff&rdquo;,&ldquo;here&rdquo;)
 #=> [[&ldquo;powerful&rdquo;, &ldquo;stuff&rdquo;], &ldquo;here&rdquo;]
```</p>

<h3>converts 1D array to a hash</h3>

<p>I think this is the kind of thing that doesn&rsquo;t seem very useful until you get that one rare type of problem where it ends up being perfect for. If you use splat <code>*</code> on an array as the key in a new Hash, it will automatically split the array into key-value pairs and then create the new hash. Note that it only works when you have an array with an even number of elements.</p>

<p>``` ruby array to hash using splat
animals = [&ldquo;cat&rdquo;,&ldquo;meow&rdquo;,&ldquo;snake&rdquo;,&ldquo;hiss&rdquo;]
Hash[*animals] #=> {&ldquo;cat&rdquo;=>&ldquo;meow&rdquo;, &ldquo;snake&rdquo;=>&ldquo;hiss&rdquo;}</p>

<h1>It first splits the elements into pairs and then creates the Hash:</h1>

<h1>[&ldquo;cat&rdquo;,&ldquo;meow&rdquo;,&ldquo;snake&rdquo;,&ldquo;hiss&rdquo;] ==></h1>

<h1>[&ldquo;cat&rdquo;=>&ldquo;meow&rdquo;,&ldquo;snake&rdquo;=>&ldquo;hiss&rdquo;] ==></h1>

<h1>{&ldquo;cat&rdquo;=>&ldquo;meow&rdquo;, &ldquo;snake&rdquo;=>&ldquo;hiss&rdquo;}</h1>

<p>```</p>
]]></content>
  </entry>
  
</feed>
